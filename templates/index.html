<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Sign Translation - Browser Mode</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- MediaPipe Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js" crossorigin="anonymous"></script>
    <style>
        .video-container {
            transform: scaleX(-1);
        }
        #canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }
        #video {
            transform: scaleX(-1);
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-center p-4">
    <div class="max-w-4xl w-full bg-white rounded-xl shadow-2xl overflow-hidden">
        <div class="bg-blue-600 p-6 text-white text-center">
            <h1 class="text-3xl font-bold">Hand Sign Translator</h1>
            <p class="text-blue-100">Real-time Browser-based Detection</p>
        </div>
        
        <div class="p-6">
            <div class="relative rounded-lg overflow-hidden bg-black aspect-video mb-6">
                <video id="video" autoplay playsinline></video>
                <canvas id="canvas"></canvas>
                <div id="loading" class="absolute inset-0 flex flex-col items-center justify-center bg-black bg-opacity-70 text-white">
                    <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-white mb-4"></div>
                    <span class="text-xl">Initializing AI Models...</span>
                </div>
            </div>

            <div class="bg-gray-50 rounded-lg p-6 border border-gray-200 mb-6">
                <h2 class="text-lg font-semibold text-gray-700 mb-3">Detected Alphabet:</h2>
                <div id="translations" class="flex flex-wrap gap-3">
                    <span class="text-gray-400 italic">Detecting hands...</span>
                </div>
            </div>

            <div class="bg-white rounded-lg p-6 border border-gray-200 shadow-inner">
                <div class="flex justify-between items-center mb-3">
                    <h2 class="text-lg font-semibold text-gray-700">Composed Sentence:</h2>
                    <button onclick="clearSentence()" class="text-red-500 hover:text-red-700 text-sm font-medium">Clear All</button>
                </div>
                <div id="sentence" class="text-2xl font-mono min-h-[3rem] p-3 bg-gray-50 rounded border border-dashed border-gray-300 break-words">
                    <span class="text-gray-400">Sentence will appear here...</span>
                </div>
                <div class="flex flex-col gap-1 mt-2">
                    <p class="text-xs text-gray-400 italic">*Tahan posisi tangan selama 1.5 detik untuk memasukkan huruf.</p>
                    <p class="text-xs text-blue-500 italic font-medium">*Turunkan tangan selama 2 detik untuk memberikan spasi otomatis.</p>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

        const video = document.getElementById("video");
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const loading = document.getElementById("loading");
        const translationContainer = document.getElementById("translations");
        const sentenceContainer = document.getElementById("sentence");

        let handLandmarker;
        let modelData;
        let currentSentence = "";
        let lastChar = "";
        let charStartTime = 0;
        let lastHandSeenTime = Date.now();
        const HOLD_THRESHOLD = 1500;
        const SPACE_TIMEOUT = 2000; // 2 detik tanpa tangan = spasi

        // Initialize MediaPipe and Model
        async function init() {
            try {
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
                );
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 2
                });

                const response = await fetch('/static/model_data.json');
                modelData = await response.json();
                
                startCamera();
            } catch (error) {
                console.error("Init error:", error);
                alert("Gagal memuat model AI. Pastikan koneksi internet stabil.");
            }
        }

        async function startCamera() {
            const constraints = { video: { width: 1280, height: 720 } };
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            video.srcObject = stream;
            video.addEventListener("loadeddata", predictWebcam);
            loading.classList.add("hidden");
        }

        let lastVideoTime = -1;
        async function predictWebcam() {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            
            let startTimeMs = performance.now();
            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                const results = handLandmarker.detectForVideo(video, startTimeMs);
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (results.landmarks && results.landmarks.length > 0) {
                    lastHandSeenTime = Date.now(); // Reset timer spasi karena tangan terdeteksi
                    const translations = [];
                    
                    for (let i = 0; i < results.landmarks.length; i++) {
                        const landmarks = results.landmarks[i];
                        
                        // Safety check for handedness
                        let handedness = "Unknown";
                        if (results.handedness && results.handedness[i] && results.handedness[i][0]) {
                            handedness = results.handedness[i][0].categoryName;
                        }
                        
                        // Draw landmarks
                        drawLandmarks(ctx, landmarks);
                        
                        // Process for prediction (hanya jika model sudah siap)
                        if (modelData && modelData.labels) {
                            const processed = preProcessLandmarks(landmarks, canvas.width, canvas.height);
                            const predictionIdx = predictRF(processed);
                            const label = modelData.labels[predictionIdx];
                            
                            translations.push(`${handedness}: ${label}`);
                            
                            // Sentence logic
                            if (i === 0) { // Primary hand
                                if (label && label !== "...") {
                                    if (label === lastChar) {
                                        if (Date.now() - charStartTime > HOLD_THRESHOLD) {
                                            addChar(label);
                                            lastChar = "";
                                        }
                                    } else {
                                        lastChar = label;
                                        charStartTime = Date.now();
                                    }
                                }
                            }
                        }
                    }
                    
                    translationContainer.innerHTML = translations.map(t => `
                        <div class="bg-blue-100 text-blue-800 px-4 py-2 rounded-full font-bold shadow-sm border border-blue-200">
                            ${t}
                        </div>
                    `).join('');
                } else {
                    translationContainer.innerHTML = '<span class="text-gray-400 italic">Detecting hands...</span>';
                    lastChar = "";

                    // Logika Spasi Otomatis: Jika tidak ada tangan selama 2 detik
                    if (currentSentence.length > 0 && !currentSentence.endsWith(" ")) {
                        if (Date.now() - lastHandSeenTime > SPACE_TIMEOUT) {
                            addChar(" ");
                        }
                    }
                }
            }
            window.requestAnimationFrame(predictWebcam);
        }

        function preProcessLandmarks(landmarks, width, height) {
            // Kita butuh koordinat piksel untuk konsistensi dengan logic training sebelumnya
            let landmarkList = landmarks.map(l => [l.x * width, l.y * height]);
            
            // Convert to relative (terhadap wrist/pergelangan tangan - index 0)
            let baseX = landmarkList[0][0];
            let baseY = landmarkList[0][1];
            let relativeList = landmarkList.map(l => [l[0] - baseX, l[1] - baseY]);
            
            // Flatten
            let flattened = [];
            relativeList.forEach(l => {
                flattened.push(l[0]);
                flattened.push(l[1]);
            });
            
            // Normalize (dengan nilai absolut maksimum)
            let maxVal = 0;
            flattened.forEach(v => {
                if (Math.abs(v) > maxVal) maxVal = Math.abs(v);
            });
            
            if (maxVal === 0) return flattened;
            return flattened.map(v => v / maxVal);
        }

        // Simple Random Forest Predictor in JS
        function predictRF(input) {
            const forest = modelData.forest;
            const votes = new Array(modelData.labels.length).fill(0);
            
            for (const tree of forest) {
                let nodeIdx = 0;
                while (tree.children_left[nodeIdx] !== -1) {
                    const featureIdx = tree.feature[nodeIdx];
                    const threshold = tree.threshold[nodeIdx];
                    if (input[featureIdx] <= threshold) {
                        nodeIdx = tree.children_left[nodeIdx];
                    } else {
                        nodeIdx = tree.children_right[nodeIdx];
                    }
                }
                // Leaf node - find class with max value
                const values = tree.value[nodeIdx][0];
                let maxIdx = 0;
                for (let i = 1; i < values.length; i++) {
                    if (values[i] > values[maxIdx]) maxIdx = i;
                }
                votes[maxIdx]++;
            }
            
            let finalMaxIdx = 0;
            for (let i = 1; i < votes.length; i++) {
                if (votes[i] > votes[finalMaxIdx]) finalMaxIdx = i;
            }
            return finalMaxIdx;
        }

        function addChar(char) {
            currentSentence += char;
            sentenceContainer.innerText = currentSentence;
        }

        window.clearSentence = () => {
            currentSentence = "";
            sentenceContainer.innerText = "Sentence will appear here...";
        };

        function drawLandmarks(ctx, landmarks) {
            ctx.fillStyle = "#00FF00";
            ctx.strokeStyle = "#FFFFFF";
            ctx.lineWidth = 2;
            
            // Draw Connections (Simplified)
            const connections = [
                [0, 1], [1, 2], [2, 3], [3, 4], // Thumb
                [0, 5], [5, 6], [6, 7], [7, 8], // Index
                [5, 9], [9, 10], [10, 11], [11, 12], // Middle
                [9, 13], [13, 14], [14, 15], [15, 16], // Ring
                [13, 17], [0, 17], [17, 18], [18, 19], [19, 20] // Pinky
            ];

            connections.forEach(([i, j]) => {
                ctx.beginPath();
                ctx.moveTo(landmarks[i].x * canvas.width, landmarks[i].y * canvas.height);
                ctx.lineTo(landmarks[j].x * canvas.width, landmarks[j].y * canvas.height);
                ctx.stroke();
            });

            landmarks.forEach(l => {
                ctx.beginPath();
                ctx.arc(l.x * canvas.width, l.y * canvas.height, 4, 0, 2 * Math.PI);
                ctx.fill();
            });
        }

        init();
    </script>
</body>
</html>
